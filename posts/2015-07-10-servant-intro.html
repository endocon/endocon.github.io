<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="author" content>

    <title>ARoW.info Blog -- Servant, Type Families, and Type-level Everything</title>

    <!-- Bootstrap Core CSS -->
    <link href="../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet"> -->

    <!-- Pandoc syntax highlighting CSS -->
    <link href="../css/syntax.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="../css/clean-blog.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
								<a class="navbar-brand" href="//www.arow.info"><img height="30px" src="//www.arow.info/img/logo.png"></a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="//www.arow.info">Home</a>
                    </li>
                    <li>
                        <a href="../index.html">Blog</a>
                    </li>
                    <!-- <li> -->
                    <!--     <a href="/post.html">Sample Post</a> -->
                    <!-- </li> -->
                    <!-- <li> -->
                    <!--     <a href="/contact.html">Contact</a> -->
                    <!-- </li> -->
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
    <header class="intro-header" style="background-image: url('../img/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                  <div class="post-heading">
                    <h1>Servant, Type Families, and Type-level Everything</h1>
                    <h2 class="subheading">A look at advanced GHC features used in Servant</h2><span class="meta">Posted by <a href="http://functor.tokyo">Dennis Gosnell</a></span>
                  </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
              <p>Servant is a really nice library for building REST APIs in Haskell. However, it uses advanced GHC features which may not be familiar to some Haskell programmers. In this article, I explain type-level strings, type-level lists, type-level operators, and type families. Finally, I use code from servant-server to explain how these features are used in practice.</p>
<p>This article is aimed at people who have a basic familiarity with Haskell. This includes understanding things like typeclasses, applicatives, monads, monad transformers, pointfree style, ghci, etc.</p>
<p>This article will give you insight to how Servant is using these advanced Haskell features, and hopefully make you more productive when using Servant.</p>
<h2 id="servant-example">Servant Example</h2>
<p>Here is a simple example of using servant-server. This code will be referred to throughout the article.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans.Either</span> (<span class="dt">EitherT</span>)
<span class="kw">import </span><span class="dt">Network.Wai</span> (<span class="dt">Application</span>)
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)
<span class="kw">import </span><span class="dt">Network.Wai.Middleware.RequestLogger</span> (logStdoutDev)
<span class="kw">import </span><span class="dt">Servant</span>
    ( (<span class="fu">:&gt;</span>), (<span class="fu">:&lt;|&gt;</span>)((<span class="fu">:&lt;|&gt;</span>)), <span class="dt">Get</span>, <span class="dt">JSON</span>, <span class="dt">Proxy</span>(<span class="fu">..</span>), <span class="dt">ServantErr</span>, <span class="dt">ServerT</span>, serve )

<span class="co">-- | A representation of our REST API at the type level.</span>
<span class="fu">--</span>
<span class="co">-- This defines two routes:</span>
<span class="co">--   * /dogs -- Responds to HTTP GET with a list of integers in JSON format.</span>
<span class="co">--   * /cats -- Responds to HTTP GET with a list of Strings in JSON format.</span>
<span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="co">-- | A WAI 'Application' that will serve our API.</span>
<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI

<span class="co">-- | Our entire API.  You can see that it is a combination of the 'dogNums'</span>
<span class="co">-- handler and the 'cats' handler.</span>
<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats

<span class="co">-- | A handler for the /dogs route.  It just returns a list of the integers</span>
<span class="co">-- one to four.</span>
<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="co">-- | A handler for the /cats route.</span>
<span class="ot">cats ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">String</span>]
cats <span class="fu">=</span> return [<span class="st">&quot;long-haired&quot;</span>, <span class="st">&quot;short-haired&quot;</span>]

<span class="co">-- | Run our 'app' as a WAI 'Application'.</span>
<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> run <span class="dv">32323</span> <span class="fu">$</span> logStdoutDev app</code></pre></div>
<p>The example project can be found <a href="https://github.com/cdepillabout/servant-example/commits/master">on Github</a>. The comments in the code should give a good idea as to what is going on, but if you would like a better introduction, the <a href="http://haskell-servant.github.io/tutorial/">Servant tutorial</a> is very good.</p>
<p>The following steps can be used to download and run the code. The <a href="https://github.com/commercialhaskell/stack">stack</a> build tool is used.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">git</span> clone git@github.com:cdepillabout/servant-example.git
$ <span class="kw">cd</span> servant-example
$ <span class="kw">stack</span> build
$ <span class="kw">stack</span> exec servant-notes</code></pre></div>
<p>This runs a Warp server on port 32323. With the server running, <code>curl</code> can be used to test the API.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:32323/dogs
[<span class="kw">1</span>,2,3,4]
$ <span class="kw">curl</span> http://localhost:32323/cats
[<span class="st">&quot;long-haired&quot;</span>,<span class="st">&quot;short-haired&quot;</span>]
$</code></pre></div>
<p>The code can also be opened in <code>ghci</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> stack ghci
ghci<span class="fu">&gt;</span> <span class="fu">:</span>load example<span class="fu">.</span>hs
ghci<span class="fu">&gt;</span> <span class="fu">:</span>info app
<span class="ot">app ::</span> <span class="dt">Application</span>      <span class="co">-- Defined at example.hs:17:1</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<h2 id="the-motivation-for-servant">The Motivation for Servant</h2>
<p>Why does Servant exist? What is the main problem it solves?</p>
<p>Most web frameworks allow the user to write a handler for a specific route as a function. Here is an example of a handler function for a theoretical framework returning a JSON list <code>[1,2,3,4]</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dogNums' ::</span> <span class="dt">SomeMonad</span> <span class="dt">Value</span>
dogNums' <span class="fu">=</span> return <span class="fu">$</span> toJSON [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<p>When a user makes a request to <code>/dogs</code>, this function would get called, and the framework would pass the generated JSON back to the user. The type of the handler function is <code>SomeMonad Value</code>. This means it is running in <code>SomeMonad</code> and returning a JSON <code>Value</code>.</p>
<p>This is not bad, but it’s not type safe. All the type signature says is that some kind of JSON is returned.</p>
<p>It would be nice to enforce that a list of <code>Int</code>s is returned. Ideally we would like to write this function like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dogNums'' ::</span> <span class="dt">SomeMonad</span> [<span class="dt">Int</span>]
dogNums'' <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<p>The framework would be responsible for converting the list of <code>Int</code>s to JSON and returning it to the user.</p>
<p>Servant does this for us.</p>
<p>In our example, there are two handlers for two different routes. Here is the handler for the <code>/dogs</code> route:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<p>How does <code>dogNums</code> relate to <code>dogNums''</code>?</p>
<p><code>SomeMonad</code> would be <code>EitherT ServantErr IO</code>. The list of <code>Int</code>s is the same.</p>
<p>Servant is great because it gives us type safety in the return type of our handlers.</p>
<p>However, two important things are still missing. Servant needs to be told that the handler should be called when the user sends a GET request to <code>/dogs</code>. Servant also needs to be told to convert the <code>Int</code> list returned by the <code>dogNums</code> handler to JSON.</p>
<p>This information is encoded in the API type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DogsAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span></code></pre></div>
<p>This type says that Servant will respond to GET requests to <code>/dogs</code>, returning a JSON-encoded list of <code>Int</code>s.</p>
<p>Before explaining how the <code>dogNums</code> function gets tied to the <code>DogsAPI</code> type, we first need to look at type-level strings, type-level lists, type-level operators, and type families.</p>
<h2 id="type-level-strings">Type-Level Strings</h2>
<p>Recent versions of GHC support <a href="https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html">type-level strings</a>. What’s a type-level string? Let’s play around with it in ghci.</p>
<p>First, the DataKinds language extension needs to be enabled.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XDataKinds</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>Let’s try to get the kind of a type-level string:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="st">&quot;hello&quot;</span>
<span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">GHC.TypeLits.Symbol</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>Hmm, the type-level string appears to be of kind <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-TypeLits.html#t:Symbol"><code>GHC.TypeLits.Symbol</code></a>. What can be done with this?</p>
<p>Looking at the <code>GHC.TypeLits</code> module, there appears to be a <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-TypeLits.html#v:symbolVal"><code>symbolVal</code></a> function. It can be used to get back the <strong>value</strong> of the type-level string.</p>
<p>Let’s try this out in ghci. <code>symbolVal</code> and <a href="https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Proxy.html#t:Proxy"><code>Data.Proxy.Proxy</code></a> need to be imported. <code>Proxy</code> is used to “proxy” the type-level literal.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">GHC.TypeLits</span>
ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Proxy</span>
ghci<span class="fu">&gt;</span> symbolVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;hello&quot;</span>)
<span class="st">&quot;hello&quot;</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>This is really cool! We are able to get back the <strong>concrete value</strong> of something that only exists on the <strong>type level</strong>!</p>
<p>How does Servant use this? Recall the <code>MyAPI</code> type defined near the top of this article:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span></code></pre></div>
<p><code>&quot;dogs&quot;</code> and <code>&quot;cats&quot;</code> are type-level strings. At the end of this article we will look at some servant-server code and confirm that it is using <code>symbolVal</code> to get the value of the type-level strings.</p>
<h2 id="type-level-lists">Type-Level Lists</h2>
<p>Just like type-level strings, type-level lists can also be defined.</p>
<p>First, the <code>DataKinds</code> language extension needs to be enabled.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XDataKinds</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>Let’s look at the kind of a type-level empty list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind []
[]<span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>No, wait, that’s not right. That’s just the kind of the normal list constructor. How do we write a type-level list?</p>
<p>Take quick peek at the GHC page on <a href="https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/promotion.html">datatype promotion</a>. The first section is pretty interesting, as is the section on the <a href="https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/promotion.html#promoted-lists-and-tuples">promoted list and tuple types</a>. There is a short example of a heterogeneous list (or <code>HList</code>). A heterogeneous list is a list that has elements of different types. In the example, <code>foo2</code> represents a heterogeneous list with two elements, <code>Int</code> and <code>Bool</code>.</p>
<p>From the example, you can see that type-level lists can be defined by putting a quote in front of the opening bracket:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="ch">'[]</span>
<span class="ch">'[] :: [k]</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>Type-level lists can also be defined with multiple elements:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="ch">'[Int, Bool, String]</span>
<span class="ch">'[Int, Bool, String] :: [*]</span>
ghci<span class="fu">&gt;</span></code></pre></div>
<p>Going back to the <code>MyAPI</code> example from above, Servant is using type-level lists to represent the available content-type encodings of the response.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span></code></pre></div>
<p>Servant is only willing to send back responses in JSON. (Because JSON is the only type in the type-level list).</p>
<p>Additional content types could also be specified:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON, FormUrlEncoded] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON, PlainText] Text</span></code></pre></div>
<p>(However, to get this to compile, there would need to be an instance of <code>ToFormUrlEncoded [Int]</code>.) The <code>/dogs</code> route will then return either JSON or form-encoded values. The <code>/cats</code> route will return either JSON or plain text.</p>
<p>I’m not going to go into how type-level lists are used in servant-server, but if you’re interested you may want to start with reading the <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant-server/src/Servant/Server/Internal.hs#L230"><code>Get</code> instance for <code>HasServer</code></a>, which will take you to the <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant-server/src/Servant/Server/Internal.hs#L123"><code>methodRouter</code></a> function, which will take you to the <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant/src/Servant/API/ContentTypes.hs#L158"><code>AllCTRender</code></a> typeclass. The <code>AllCTRender</code> typeclass/instance is where the real magic starts happening.</p>
<p>Oliver Charles has an <a href="https://ocharles.org.uk/blog/posts/2014-08-07-postgresql-simple-generic-sop.html">interesting post</a> on the generics-sop package where he talks a little about heterogeneous lists.</p>
<h2 id="type-level-operators">Type-Level Operators</h2>
<p>In the Servant example code above, there are two type-level operators being used: <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant/src/Servant/API/Sub.hs#L17"><code>(:&gt;)</code></a> and <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant/src/Servant/API/Alternative.hs#L19"><code>(:&lt;|&gt;)</code></a>. Type-level operators are similar to normal data types—they are just composed of symbols instead of letters.</p>
<p>Let’s look at how <code>(:&gt;)</code> and <code>(:&lt;|&gt;)</code> are defined in Servant:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> path <span class="fu">:&gt;</span> a

<span class="kw">data</span> a <span class="fu">:&lt;|&gt;</span> b <span class="fu">=</span> a <span class="fu">:&lt;|&gt;</span> b</code></pre></div>
<p>If we didn’t want to write them infix, they could be written like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> (<span class="fu">:&gt;</span>) path a

<span class="kw">data</span> (<span class="fu">:&lt;|&gt;</span>) a b <span class="fu">=</span> (<span class="fu">:&lt;|&gt;</span>) a b</code></pre></div>
<p>In fact, if these data types were written with letters instead of symbols, they would look something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> path a

<span class="kw">data</span> <span class="dt">Bar</span> a b <span class="fu">=</span> <span class="dt">Bar</span> a b</code></pre></div>
<p>You can see that <code>(:&gt;)</code> and <code>(:&lt;|&gt;)</code> are just normal datatype definitions. They only look weird because they are made of symbols and written infix.</p>
<p>Type operators help when writing long type definitions. They keep the long type definition easy to understand. Take the following API definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;foo&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;bar&quot;</span> <span class="fu">&gt;:</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span></code></pre></div>
<p>This defines the route <code>/foo/bar</code>. Rewriting this prefix would look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> (<span class="fu">:&gt;</span>) <span class="st">&quot;foo&quot;</span> ((<span class="fu">&gt;:</span>) <span class="st">&quot;bar&quot;</span> (<span class="dt">Get</span> <span class="ch">'[JSON] [Int]))</span></code></pre></div>
<p>You can see how much easier the infix style is to read!</p>
<p><strong>NOTE</strong>: The <code>TypeOperators</code> language extension is needed to use the above code.</p>
<p>The GHC manual has a section about <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-operators">type-operators</a>.</p>
<p>You may be thinking, “<em>These type operators are pretty neat, but how are they actually used? They just look like confusing data types!</em>” Well, we’ll get to that in a minute. Before we can jump into the Servant code, we need to get a basic understanding of type families.</p>
<h2 id="type-families">Type Families</h2>
<p>Type families are a relatively simple addition to Haskell that allow the user to do some computation at the type level. However, if you google for <a href="https://www.google.co.jp/search?q=haskell+type+families&amp;ie=utf-8&amp;oe=utf-8&amp;gws_rd=cr&amp;ei=OzuSVZSMA6S-mAX044aoCQ">type families</a>, it’s easy to get scared.</p>
<p>The first result is the <a href="https://wiki.haskell.org/GHC/Type_families">GHC/Type families</a> article on the Haskell Wiki. This is written with an advanced Haskeller in mind. Don’t worry if it’s too hard. (The other problem is that most of their examples use data families instead of type synonym families–which I introduce below. Most of the real world Haskell code I’ve seen uses type synonym families much more than data families).</p>
<p>The second link is to the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-families.html">type-families page</a> in the GHC manual. It’s good if you already know about type families and just want a refresher, but it’s not good as an introduction to type families.</p>
<p>The third result is an <a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/type-families-and-pokemon">article</a> on FP Complete. It gets points for being about Pokemon, but the setup/motivation for using type families is way too long<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p>
<p>The fourth result is an introduction to <a href="https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html">type families</a> by Oliver Charles. It’s the best of the bunch, but it is slightly hard to follow if you’ve never used MVars, IORefs, etc.</p>
<p>I wrote a super simple <em>tl;dr</em> <a href="https://cdepillabout.github.io/haskell-type-families-presentation">presentation about type families</a>. Originally I wrote it in Japanese for a Haskell Lightning Talk in Tokyo, but I recently translated it to English upon the request from someone in the <strong>#haskell</strong> room in the <a href="http://fpchat.com/">functional programming slack community</a>. If you aren’t sure about type families, please read that presentation and then proceed to the next section.</p>
<h2 id="servant">Servant</h2>
<p>Now we come to the interesting section. How does Servant actually use type-level strings, type-level lists, type-operators, and type families? Let’s go back to the example code at the top of this blog post:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans.Either</span> (<span class="dt">EitherT</span>)
<span class="kw">import </span><span class="dt">Network.Wai</span> (<span class="dt">Application</span>)
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)
<span class="kw">import </span><span class="dt">Network.Wai.Middleware.RequestLogger</span> (logStdoutDev)
<span class="kw">import </span><span class="dt">Servant</span>
    ( (<span class="fu">:&gt;</span>), (<span class="fu">:&lt;|&gt;</span>)((<span class="fu">:&lt;|&gt;</span>)), <span class="dt">Get</span>, <span class="dt">JSON</span>, <span class="dt">Proxy</span>(<span class="fu">..</span>), <span class="dt">ServantErr</span>, <span class="dt">ServerT</span>, serve )

<span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI

<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats

<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="ot">cats ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">String</span>]
cats <span class="fu">=</span> return [<span class="st">&quot;long-haired&quot;</span>, <span class="st">&quot;short-haired&quot;</span>]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> run <span class="dv">32323</span> <span class="fu">$</span> logStdoutDev app</code></pre></div>
<p>We have the <code>MyAPI</code> type and the two handlers for the <code>/dogs</code> and <code>/cats</code> routes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="ot">cats ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">String</span>]
cats <span class="fu">=</span> return [<span class="st">&quot;long-haired&quot;</span>, <span class="st">&quot;short-haired&quot;</span>]</code></pre></div>
<p>Our goal is to figure out how we get from the <code>/dogs</code> API type, to the actual handler type.</p>
<dl>
<dt>API type</dt>
<dd><p><code>&quot;dogs&quot; :&gt; Get '[JSON] [Int]</code></p>
</dd>
<dt>handler type</dt>
<dd><p><code>EitherT ServantErr IO [Int]</code></p>
</dd>
</dl>
<p>The following sections dive into actual code from servant-server’s <a href="https://github.com/haskell-servant/servant/tree/3dc304b8d7c9dbf2fb57afbc1d687f1ec8b48106/servant-server">master branch</a> on Github. The code is currently between version 0.4.2 and 0.5.0.</p>
<h2 id="serve">Serve!</h2>
<p>In the example code above, the two interesting functions are <code>serve</code> and <code>myAPI</code>. <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#v:serve"><code>serve</code></a> is provided by <a href="https://hackage.haskell.org/package/servant-server">servant-server</a>, while <code>myAPI</code> is written by us.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI

<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>Let’s look at the type of serve:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Servant.Server</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> serve
<span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout
                          <span class="ot">-&gt;</span> <span class="dt">Server</span> layout
                          <span class="ot">-&gt;</span> <span class="dt">Network.Wai.Application</span></code></pre></div>
<p>Let’s start with the easy things. It returns a <a href="https://hackage.haskell.org/package/wai-3.0.3.0/docs/Network-Wai.html#t:Application"><code>Network.Wai.Application</code></a>. This represents an application that can be served by Warp (i.e. something that can be passed to the <a href="https://hackage.haskell.org/package/warp-3.0.13.1/docs/Network-Wai-Handler-Warp.html#v:run"><code>run</code></a> function provided by Warp).</p>
<p>The first argument is <code>Proxy layout</code>. The <code>serve</code> function uses this to figure out what the API type is. You might be asking, “<em>If we are also passing the <code>layout</code> type variable to the <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#t:Server"><code>Server</code></a> type constructor, why do we additionally need to pass a <code>Proxy layout</code>? Surely, we don’t need to pass <code>layout</code> twice?</em>”. That will be covered later.</p>
<p>(If you don’t understand this, look at the type of the <code>serve</code> function again:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout
                          <span class="ot">-&gt;</span> <span class="dt">Server</span> layout
                          <span class="ot">-&gt;</span> <span class="dt">Network.Wai.Application</span></code></pre></div>
<p><code>layout</code> is specified twice, when it should only have to be specified once, right?)</p>
<p>Now look at the second argument, <code>Server layout</code>. What is <code>Server</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Server</span>
<span class="kw">type</span> <span class="dt">Server</span> layout <span class="fu">=</span> <span class="dt">ServerT</span> layout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)</code></pre></div>
<p><code>Server</code> looks like it is a specialization of <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#t:ServerT"><code>ServerT</code></a> around the <a href="https://hackage.haskell.org/package/either-4.4.1/docs/Control-Monad-Trans-Either.html#t:EitherT"><code>EitherT</code></a> monad transformer. This is similar to how the <a href="https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Reader.html#t:Reader"><code>Reader</code></a> monad is a specialization of the <a href="https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT"><code>ReaderT</code></a> monad<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="fu">=</span> <span class="fu">...</span>
<span class="kw">type</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span> a</code></pre></div>
<p>Okay, so <code>Server</code> is just a specialization of <code>ServerT</code>. Then what is <code>ServerT</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">ServerT</span>
<span class="kw">class</span> <span class="dt">HasServer</span> (<span class="ot">layout ::</span> k) <span class="kw">where</span>
  <span class="kw">type</span> family <span class="dt">ServerT</span> (<span class="ot">layout ::</span> k) (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">...</span></code></pre></div>
<p>This is what we’ve been waiting for! <code>ServerT</code> is a type family! It’s a function that computes a type. Let’s take a look at the <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#t:HasServer"><code>HasServer</code></a> typeclass before really diving into <code>ServerT</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasServer</span> layout <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>

<span class="ot">  route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>))) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p><code>HasServer</code> takes one type parameter, <code>layout</code>. <code>ServerT</code> is a type family that takes two parameters, <code>layout</code> and <code>m</code>.</p>
<p>There is one function in this typeclass, <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#v:route"><code>route</code></a>. It takes a <code>Proxy layout</code> and an <code>IO</code> of a <code>RouteResult</code> of a <code>ServerT</code> with the <code>m</code> parameter specialized to <code>EitherT ServantErr IO</code>. Quite a mouthful. Let’s abbreviate part of the type to make it easier to digest:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>Basically <code>route</code> takes an <code>IO</code> of a <code>RouteResult</code> of a <code>ServerT</code> and returns a <code>Router</code>. Let’s go back real quick and look at the implementation of the <code>serve</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">ServerT</span> layout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>) <span class="ot">-&gt;</span> <span class="dt">Application</span>
serve proxy server <span class="fu">=</span> toApplication (runRouter (route proxy (return (<span class="dt">RR</span> (<span class="dt">Right</span> server)))))</code></pre></div>
<p>The type of the <code>serve</code> function looks pretty similar to the <code>route</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span>                 (<span class="dt">ServerT</span> layout <span class="fu">...</span>)  <span class="ot">-&gt;</span> <span class="dt">Application</span>
<span class="ot">route ::</span>                     <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>So how does the <code>serve</code> function work? It’s basically taking our <code>myAPI</code> (the <code>server</code> argument below) argument, wrapping it in a <code>RouteResult</code> and <code>IO</code>, then passing it to the <code>route</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>) <span class="ot">-&gt;</span> <span class="dt">Application</span>
serve proxy server <span class="fu">=</span> toApplication (runRouter (route proxy (return (<span class="dt">RR</span> (<span class="dt">Right</span> server)))))
                                                           <span class="fu">^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>
                                                           look at all this wrapping<span class="fu">!!!</span></code></pre></div>
<p>It takes the resulting <code>Router</code> from the <code>route</code> function, passes it to <code>runRouter</code>, and then passes that to <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#v:toApplication"><code>toApplication</code></a> to get the Wai application. Pretty easy! Let’s see it point free!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>) <span class="ot">-&gt;</span> <span class="dt">Application</span>
serve proxy <span class="fu">=</span> toApplication <span class="fu">.</span> runRouter <span class="fu">.</span> route proxy <span class="fu">.</span> return <span class="fu">.</span> <span class="dt">RR</span> <span class="fu">.</span> <span class="dt">Right</span>
                                                        <span class="fu">^^^^^^^^^^^^^^^^^^^</span>
                                                  look at this pointfree wrapping<span class="fu">!!!</span></code></pre></div>
<p>Understanding <code>serve</code> isn’t strictly necessary to understanding the rest of this article, but it is interesting.</p>
<h2 id="our-progress-so-far">Our Progress so far</h2>
<p>Here’s what we’ve learned so far, in convenient bullet-point form:</p>
<ul>
<li><p>We have a <code>MyAPI</code> type, and we want to figure out how that gets translated to the <code>dogNums</code> and <code>cats</code> handler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="ot">cats ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">String</span>]
cats <span class="fu">=</span> return [<span class="st">&quot;long-haired&quot;</span>, <span class="st">&quot;short-haired&quot;</span>]</code></pre></div></li>
<li><p>It looks like the translation is basically happening in the Servant-provided <code>serve</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI

<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div></li>
<li><p>The <code>serve</code> function is basically just calling <code>route</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>) <span class="ot">-&gt;</span> <span class="dt">Application</span>
serve proxy <span class="fu">=</span> toApplication <span class="fu">.</span> runRouter <span class="fu">.</span> route proxy <span class="fu">.</span> return <span class="fu">.</span> <span class="dt">RR</span> <span class="fu">.</span> <span class="dt">Right</span></code></pre></div></li>
<li><p>The <code>route</code> function is defined in the <code>HasServer</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasServer</span> layout <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>

<span class="ot">  route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div></li>
</ul>
<p>The next section will look at how the <code>HasServer</code> typeclass and <code>route</code> function interact to convert <code>&quot;dogs&quot; :&gt; Get '[JSON] [Int]</code> to <code>EitherT ServantErr IO [Int]</code>.</p>
<h2 id="hasserver-one-more-time"><code>HasServer</code>, one more time</h2>
<p>Let’s go back to the <code>HasServer</code> typeclass. Here it is again:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasServer</span> layout <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>

<span class="ot">  route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>))) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>This typeclass specifies things that can be used to create a <code>Router</code>. A <code>Router</code> can then be turned into a Wai application.</p>
<p>So what instances are available for the <code>HasServer</code> typeclass? Let’s ask ghci.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>info<span class="fu">!</span> <span class="dt">HasServer</span>
<span class="fu">...</span>
<span class="kw">instance</span> <span class="dt">AllCTRender</span> ctypes a <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">Get</span> ctypes a)
<span class="fu">...</span>
<span class="kw">instance</span> (<span class="dt">KnownSymbol</span> path, <span class="dt">HasServer</span> sublayout) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (path <span class="fu">:&gt;</span> sublayout)
<span class="kw">instance</span> (<span class="dt">HasServer</span> a, <span class="dt">HasServer</span> b) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (a <span class="fu">:&lt;|&gt;</span> b)
ghci<span class="fu">&gt;</span></code></pre></div>
<p><code>:info!</code> shows us all the instances defined for a typeclass. Look at the difference between <code>:info HasServer</code> and <code>:info! HasServer</code>.</p>
<p>There are instances defined for <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant-server/src/Servant/Server/Internal.hs#L230"><code>Get</code></a>, <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant-server/src/Servant/Server/Internal.hs#L715"><code>(:&gt;)</code></a>, <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant-server/src/Servant/Server/Internal.hs#L79"><code>(:&lt;|&gt;)</code></a>. I know where we’ve seen those before! The <code>MyAPI</code> type!</p>
<p>Let’s take a look at the <code>MyAPI</code> type defined earlier in the example code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span></code></pre></div>
<p>Remember how type-level operators can be rewritten to prefix form? Rewriting <code>(:&lt;|&gt;)</code> to prefix form becomes this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> (<span class="fu">:&lt;|&gt;</span>) (<span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]) (&quot;cats&quot; :&gt; Get '</span>[<span class="dt">JSON</span>] [<span class="dt">String</span>])</code></pre></div>
<p>The inner <code>(:&gt;)</code> could also be rewritten to prefix form and it will get <em>even uglier</em>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> (<span class="fu">:&lt;|&gt;</span>) ((<span class="fu">:&gt;</span>) <span class="st">&quot;dogs&quot;</span> (<span class="dt">Get</span> <span class="ch">'[JSON] [Int])) ((:&gt;) &quot;cats&quot; (Get '</span>[<span class="dt">JSON</span>] [<span class="dt">String</span>]))</code></pre></div>
<p>Okay, so here’s where the explanation starts to get a little difficult. Remember the <code>app</code> function?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI

<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats

<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="ot">cats ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
cats <span class="fu">=</span> return [<span class="st">&quot;long-haired&quot;</span>, <span class="st">&quot;short-haired&quot;</span>]</code></pre></div>
<p>It’s just calling serve and passing it two things:</p>
<ul>
<li><p>a <code>Proxy</code> with the <code>MyAPI</code> type.</p></li>
<li><p>the <code>myAPI</code> function, which is the actual implementation of the API.</p></li>
</ul>
<p>You remember what <code>serve</code> does, right?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">ServerT</span> layout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>) <span class="ot">-&gt;</span> <span class="dt">Application</span>
serve proxy server <span class="fu">=</span> toApplication (runRouter (route proxy (return (<span class="dt">RR</span> (<span class="dt">Right</span> server)))))</code></pre></div>
<p>It basically calls <code>route</code> with the proxy and the implementation of the API.</p>
<p>Now for the interesting part. Since <code>HasServer</code> is a typeclass, what <code>route</code> function actually gets called? If we look at the <code>HasServer</code> typeclass once again, we can see that the specific <code>route</code> function that gets called depends on the type of <code>layout</code> (which gets passed to <code>route</code> as <code>Proxy layout</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasServer</span> layout <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>

<span class="ot">  route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p><code>layout</code> originally comes from the <code>app</code> function in the example code.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI</code></pre></div>
<p>Here it’s <code>MyAPI</code>. What’s the prefix form of <code>MyAPI</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> (<span class="fu">:&lt;|&gt;</span>) ((<span class="fu">:&gt;</span>) <span class="st">&quot;dogs&quot;</span> (<span class="dt">Get</span> <span class="ch">'[JSON] [Int])) ((:&gt;) &quot;cats&quot; (Get '</span>[<span class="dt">JSON</span>] [<span class="dt">String</span>]))</code></pre></div>
<p>Okay, great! So it looks like the <code>HasServer</code> instance for <code>(:&lt;|&gt;)</code> can be used! What does it look like?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">HasServer</span> a, <span class="dt">HasServer</span> b) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (a <span class="fu">:&lt;|&gt;</span> b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> (a <span class="fu">:&lt;|&gt;</span> b) m <span class="fu">=</span> <span class="dt">ServerT</span> a m <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b m

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (a <span class="fu">:&lt;|&gt;</span> b)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> ( <span class="dt">ServerT</span> a (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
                        <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b (<span class="dt">Eithert</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
                           )
              )
        <span class="ot">-&gt;</span> <span class="dt">Router</span>
  route <span class="dt">Proxy</span> server <span class="fu">=</span> choice (route pa (extractL <span class="fu">&lt;$&gt;</span> server))
                              (route pb (extractR <span class="fu">&lt;$&gt;</span> server))
    <span class="kw">where</span> pa <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a
          pb <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> b</code></pre></div>
<p>What’s going on here? The first thing to notice is that the value of the <code>ServerT (a :&lt;|&gt; b) m</code> type family becomes <code>ServerT a m :&lt;|&gt; ServerT b m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ServerT</span> (a <span class="fu">:&lt;|&gt;</span> b) m <span class="fu">=</span> <span class="dt">ServerT</span> a m <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b m</code></pre></div>
<p>What’s the significance of this? Two things. One, the new, specialized type of <code>route</code> can be deduced:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">route ::</span> <span class="dt">Proxy</span> layout     <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>)              ) <span class="ot">-&gt;</span> <span class="dt">Router</span>
<span class="co">-- becomes</span>
<span class="ot">route ::</span> <span class="dt">Proxy</span> (a <span class="fu">:&lt;|&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> a <span class="fu">...</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>And two, the type of the <code>myAPI</code> function from the example program can be changed to this specialized type, and the example program will still compile. Before, it looked like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>But it could be changed to this<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">ServerT</span> (<span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]) (EitherT ServantErr IO)</span>
    <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> (<span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]) (EitherT ServantErr IO)</span>
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>It still compiles! That’s great!</p>
<h2 id="one-level-deeper">One Level Deeper</h2>
<p>Going back to the <code>HasServer</code> instance for <code>(:&lt;|&gt;)</code>, we see that the <code>route</code> function calls itself recursively on both arguments to <code>(:&lt;|&gt;)</code>. For these recursive calls, which <code>route</code> function will be called?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">HasServer</span> a, <span class="dt">HasServer</span> b) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (a <span class="fu">:&lt;|&gt;</span> b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> (a <span class="fu">:&lt;|&gt;</span> b) m <span class="fu">=</span> <span class="dt">ServerT</span> a m <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b m

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (a <span class="fu">:&lt;|&gt;</span> b)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> ( <span class="dt">ServerT</span> a (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
                        <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b (<span class="dt">Eithert</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
                           )
              )
        <span class="ot">-&gt;</span> <span class="dt">Router</span>
  route <span class="dt">Proxy</span> server <span class="fu">=</span> choice (route pa (extractL <span class="fu">&lt;$&gt;</span> server))
                              (route pb (extractR <span class="fu">&lt;$&gt;</span> server))
    <span class="kw">where</span> pa <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a
          pb <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> b</code></pre></div>
<p>Recall our <code>MyAPI</code> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span></code></pre></div>
<p>The first argument to <code>(:&lt;|&gt;)</code> is the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span></code></pre></div>
<p>Written infix it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="fu">:&gt;</span>) <span class="st">&quot;dogs&quot;</span> (<span class="dt">Get</span> <span class="ch">'[JSON] [Int])</span></code></pre></div>
<p>You can probably see where this is going. In the recursive calls to <code>route</code>, the <code>route</code> function for the <code>(:&gt;)</code> instance of <code>HasServer</code> will be called.</p>
<p>Here is the <code>HasServer</code> instance for <code>(:&gt;)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">KnownSymbol</span> path, <span class="dt">HasServer</span> sublayout) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (path <span class="fu">:&gt;</span> sublayout) <span class="kw">where</span>

  <span class="kw">type</span> <span class="dt">ServerT</span> (path <span class="fu">:&gt;</span> sublayout) m <span class="fu">=</span> <span class="dt">ServerT</span> sublayout m

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (path <span class="fu">:&gt;</span> sublayout)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> sublayout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)))
        <span class="ot">-&gt;</span> <span class="dt">Router</span>
  route <span class="dt">Proxy</span> subserver <span class="fu">=</span> <span class="dt">StaticRouter</span> <span class="fu">$</span>
    M.singleton (symbolVal proxyPath)
                (route (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> sublayout) subserver)
    <span class="kw">where</span> proxyPath <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> path</code></pre></div>
<p>The value of the <code>ServerT (path &gt;: sublayout)</code> type family becomes <code>ServerT sublayout m</code>. The <code>path</code> argument is not used.</p>
<p>Here is the specialized type of the <code>route</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">route ::</span> <span class="dt">Proxy</span> layout              <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout    <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span>
<span class="co">-- becomes</span>
<span class="ot">route ::</span> <span class="dt">Proxy</span> (path <span class="fu">:&gt;</span> sublayout) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> sublayout <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>Just like above, the type of <code>myAPI</code> can be changed to match this. After the last change, it looked like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">ServerT</span> (<span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]) (EitherT ServantErr IO)</span>
    <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> (<span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]) (EitherT ServantErr IO)</span>
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>Because the <code>path</code> argument is ignored, it can be changed to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">ServerT</span> (<span class="dt">Get</span> <span class="ch">'[JSON] [Int]) (EitherT ServantErr IO)</span>
    <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> (<span class="dt">Get</span> <span class="ch">'[JSON] [String]) (EitherT ServantErr IO)</span>
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>Still compiles! Great!</p>
<p>If the <code>path</code> argument in <code>ServerT (path :&gt; sublayout)</code> is ignored in the value of the type family, what is it actually used for?</p>
<p><code>symbolVal</code> is used to get the value of the <code>path</code> type! It’s using the value of <code>path</code> to do the routing. It’s creating a <a href="https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Lazy.html#t:Map"><code>Map</code></a> that can later be used to lookup the path piece.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">route ::</span> <span class="dt">Proxy</span> (path <span class="fu">:&gt;</span> sublayout)
      <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> sublayout (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)))
      <span class="ot">-&gt;</span> <span class="dt">Router</span>
route <span class="dt">Proxy</span> subserver <span class="fu">=</span> <span class="dt">StaticRouter</span> <span class="fu">$</span>
    Map.singleton (symbolVal proxyPath)
                  (route (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> sublayout) subserver)
  <span class="kw">where</span> proxyPath <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> path</code></pre></div>
<p><code>route</code> is then called recursively on <code>subsever</code>, which has type <code>sublayout</code>.</p>
<p>In the example code, <code>subserver</code> will be the <code>dogNums</code> function, and the <code>sublayout</code> type will be <code>Get '[JSON] [Int]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<h2 id="our-progress-so-far-2">Our Progress so far #2</h2>
<p>Here’s an update on what we’ve learned so far:</p>
<ul>
<li><p>We have a <code>MyAPI</code> type, and we want to figure out how that gets translated to the <code>dogNums</code> and <code>cats</code> handler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]

<span class="ot">cats ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">String</span>]
cats <span class="fu">=</span> return [<span class="st">&quot;long-haired&quot;</span>, <span class="st">&quot;short-haired&quot;</span>]</code></pre></div></li>
<li><p>It looks like the translation is basically happening in the Servant-provided <code>serve</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">MyAPI</span>) myAPI

<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div></li>
<li><p>The <code>serve</code> function is basically just calling <code>route</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">serve ::</span> <span class="dt">HasServer</span> layout <span class="ot">=&gt;</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>) <span class="ot">-&gt;</span> <span class="dt">Application</span>
serve proxy <span class="fu">=</span> toApplication <span class="fu">.</span> runRouter <span class="fu">.</span> route proxy <span class="fu">.</span> return <span class="fu">.</span> <span class="dt">RR</span> <span class="fu">.</span> <span class="dt">Right</span></code></pre></div></li>
<li><p>The <code>route</code> function is defined in the <code>HasServer</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasServer</span> layout <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>

<span class="ot">  route ::</span> <span class="dt">Proxy</span> layout <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>)) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div></li>
<li><p>When <code>route</code> is passed the top-level <code>MyAPI</code> type, the <code>route</code> function in the <code>HasServer</code> instance for <code>(:&lt;|&gt;)</code> is called.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">HasServer</span> a, <span class="dt">HasServer</span> b) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (a <span class="fu">:&lt;|&gt;</span> b) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> (a <span class="fu">:&lt;|&gt;</span> b) m <span class="fu">=</span> <span class="dt">ServerT</span> a m <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> b m

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (a <span class="fu">:&lt;|&gt;</span> b)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> ( <span class="dt">ServerT</span> a <span class="fu">...</span>  <span class="fu">:&lt;|&gt;</span>  <span class="dt">ServerT</span> b <span class="fu">...</span> ))
        <span class="ot">-&gt;</span> <span class="dt">Router</span>
  route <span class="dt">Proxy</span> server <span class="fu">=</span> choice (route pa (extractL <span class="fu">&lt;$&gt;</span> server))
                              (route pb (extractR <span class="fu">&lt;$&gt;</span> server))
    <span class="kw">where</span> pa <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a
          pb <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> b</code></pre></div></li>
<li><p>The type of the <code>myAPI</code> function can be changed to match the value of the <code>ServerT</code> type family:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">MyAPI</span> (<span class="dt">EitherT</span> <span class="fu">...</span>)
<span class="co">-- becomes</span>
<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> (<span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="fu">...</span>) (<span class="dt">EitherT</span> <span class="fu">...</span>)
    <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> (<span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="fu">...</span>) (<span class="dt">EitherT</span> <span class="fu">...</span>)</code></pre></div></li>
<li><p>In the <code>HasServer</code> instance for <code>(:&lt;|&gt;)</code>, <code>route</code> is called recursively with the type <code>&quot;dogs&quot; :&gt; Get '[JSON] [Int]</code>. The corresponding <code>route</code> function is defined in the <code>HasServer</code> instance for <code>(:&gt;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">KnownSymbol</span> path, <span class="dt">HasServer</span> sublayout) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (path <span class="fu">:&gt;</span> sublayout) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> (path <span class="fu">:&gt;</span> sublayout) m <span class="fu">=</span> <span class="dt">ServerT</span> sublayout m

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (path <span class="fu">:&gt;</span> sublayout)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> sublayout <span class="fu">...</span>))
        <span class="ot">-&gt;</span> <span class="dt">Router</span>
  route <span class="dt">Proxy</span> subserver <span class="fu">=</span> <span class="dt">StaticRouter</span> <span class="fu">$</span>
    M.singleton (symbolVal proxyPath)
                (route (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> sublayout) subserver)
    <span class="kw">where</span> proxyPath <span class="fu">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> path</code></pre></div>
<p>This basically throws away the path argument, and does a similar transformation to above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">ServerT</span> (<span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="fu">...</span>) (<span class="dt">EitherT</span> <span class="fu">...</span>)
<span class="co">-- becomes</span>
<span class="dt">ServerT</span> (<span class="dt">Get</span> <span class="fu">...</span>) (<span class="dt">EitherT</span> <span class="fu">...</span>)</code></pre></div></li>
</ul>
<p>We’re very close to figuring out how Servant is able to go from the <code>MyAPI</code> type <code>&quot;dogs&quot; :&gt; Get '[JSON] [Int]</code> to the type of our handler <code>EitherT ServantErr IO [Int]</code>.</p>
<p>In the next section we will look at the last part of the puzzle, the <code>Get</code> instance of <code>HasServer</code>.</p>
<h2 id="red-pill-blue-pill-bottom-of-the-rabbit-hole">Red Pill, Blue Pill, Bottom of the Rabbit Hole</h2>
<p>Here is the <code>Get</code> instance of <code>HasServer</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> ( <span class="dt">AllCTRender</span> contentTypes a ) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (<span class="dt">Get</span> contentTypes a) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">Get</span> contentTypes a) m <span class="fu">=</span> m a

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (<span class="dt">Get</span> contentTypes a)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (m a))
        <span class="ot">-&gt;</span> <span class="dt">Router</span>
  route <span class="dt">Proxy</span> <span class="fu">=</span> methodRouter methodGet (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> contentTypes) ok200</code></pre></div>
<p>Here is the specialized type of the <code>route</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">route ::</span> <span class="dt">Proxy</span> layout               <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout m)) <span class="ot">-&gt;</span> <span class="dt">Router</span>
<span class="co">-- becomes</span>
<span class="ot">route ::</span> <span class="dt">Proxy</span> (<span class="dt">Get</span> contentTypes a) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (m a))              <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>In this instance, the <code>ServerT (Get contentTypes a) m</code> type family simply becomes <code>m a</code>.</p>
<p>In our case,</p>
<ul>
<li><code>m</code> is <code>EitherT ServantErr IO</code></li>
<li><code>a</code> is <code>[Int]</code></li>
</ul>
<p><code>ServerT (Get contentTypes a) m</code> becomes <code>EitherT ServantErr IO [Int]</code>.</p>
<p>That’s why the type of <code>dogNums</code> is <code>EitherT ServantErr IO [Int]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<p>Just like above, the type of <code>myAPI</code> can be rewritten and it will still compile:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
    <span class="fu">:&lt;|&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">String</span>]
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>We won’t go into how the <code>route</code> function is implemented here, but if you are interested, you’re welcome to look at the implementation of <a href="https://github.com/haskell-servant/servant/blob/31b12d4bf468b9fd46f5c4b797f8ef11d0894aba/servant-server/src/Servant/Server/Internal.hs#L123"><code>methodRouter</code></a>. <code>methodRouter</code> does the actual rendering of the return type. For example, it will turn our <code>[Int]</code> into a JSON blob.</p>
<p>Because <code>methodRouter</code> handles the rendering of the return type, <code>route</code> needs to pass it <code>Proxy contentTypes</code> so that <code>methodRouter</code> knows what type to render.</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>At a very high-level, the <code>HasServer</code> typeclass, <code>ServerT</code> type family, and <code>route</code> function are used to peel away levels of the <code>MyAPI</code> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>
        <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span></code></pre></div>
<p>First, <code>(:&lt;|&gt;)</code> is peeled away leaving us with <code>&quot;dogs&quot; :&gt; Get '[JSON] [Int]</code>. Then <code>(:&gt;)</code> is peeled away leaving us with <code>Get '[JSON] [Int]</code>. This gets turned into the actual type of <code>dogNums</code>: <code>EitherT ServantErr IO [Int]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dogNums ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Int</span>]
dogNums <span class="fu">=</span> return [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</code></pre></div>
<h2 id="why-pass-layout-twice">Why Pass <code>layout</code> Twice?</h2>
<p>In the beginning of the <a href="#serve">Serve!</a> section, a question was asked about the <code>route</code> function and the <code>HasServer</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">HasServer</span> layout <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> layout (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span>

<span class="ot">  route ::</span> <span class="dt">Proxy</span> layout
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> layout <span class="fu">...</span>))
        <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>Here is the question that was asked:</p>
<blockquote>
<p>In the <code>route</code> function, if we are passing the <code>layout</code> type variable to the <a href="https://hackage.haskell.org/package/servant-server-0.4.2/docs/Servant-Server.html#t:ServerT"><code>ServerT</code></a> type constructor, why do we additionally need to pass a <code>Proxy layout</code>? Surely, we don’t need to pass <code>layout</code> twice?</p>
</blockquote>
<p>This question was recently <a href="http://stackoverflow.com/q/31636431/3040129">answered</a> on Stack Overflow by <a href="http://alpmestan.com/">Alp Mestanogullari</a> (one of the developers of servant).</p>
<p>He says that the main reason we need to pass <code>layout</code> twice is that type families, like <code>ServerT</code>, are not injective. An explanation of injectivity is given on the Haskell Wiki page on <a href="https://wiki.haskell.org/GHC/Type_families#Injectivity.2C_type_inference.2C_and_ambiguity">type families</a>.</p>
<p>This means that if we have <code>ServerT a m</code> and <code>ServerT b m</code>, even if we know that <code>ServerT a m == ServerT b m</code> and <code>m == m</code>, we cannot conclude that <code>a == b</code>. (This is in contrast to a type like <code>Maybe a</code> and <code>Maybe b</code>, where if we know that <code>Maybe a == Maybe b</code>, then we also know that <code>a == b</code>.)</p>
<p>The <code>route</code> function effectively doesn’t get to “see” the <code>layout</code> passed to <code>ServerT</code>. It only “sees” the the type that <code>ServerT</code> turns into.</p>
<p>For example, take this imaginary instace of <code>HasServer</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">HasServer</span> (<span class="dt">Foo</span> a) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ServerT</span> (<span class="dt">Foo</span> a) <span class="fu">=</span> a

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (<span class="dt">Foo</span> a)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> a)
        <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>If <code>route</code> wasn’t passed a <code>Proxy</code> as the first argument, its type signature would look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">route ::</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> a) <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>It wouldn’t be able to “see” the <code>Foo</code>.</p>
<p>In servant-server, a problem like this comes up with the <code>HasServer</code> instance for <code>(:&gt;)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">KnownSymbol</span> path, <span class="dt">HasServer</span> sublayout) <span class="ot">=&gt;</span> <span class="dt">HasServer</span> (path <span class="fu">:&gt;</span> sublayout) <span class="kw">where</span>

  <span class="kw">type</span> <span class="dt">ServerT</span> (path <span class="fu">:&gt;</span> sublayout) m <span class="fu">=</span> <span class="dt">ServerT</span> sublayout m

<span class="ot">  route ::</span> <span class="dt">Proxy</span> (path <span class="fu">:&gt;</span> sublayout)
        <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">RouteResult</span> (<span class="dt">ServerT</span> sublayout <span class="fu">...</span>))
        <span class="ot">-&gt;</span> <span class="dt">Router</span></code></pre></div>
<p>The <code>ServerT</code> type family completely ignores the <code>path</code> argument! In the implementation of the <code>route</code> function, if we didn’t have the <code>Proxy (path :&gt; sublayout)</code> argument, we wouldn’t be able to use the <code>path</code> argument at all!<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>If you liked this tutorial, you may also like the official <a href="http://haskell-servant.github.io/tutorial/">servant tutorial</a>, or a tutorial about using <a href="http://www.parsonsmatt.org/programming/2015/06/07/servant-persistent.html">servant with persistent</a> by <a href="http://www.parsonsmatt.org/">Matt Parsons</a>.</p>
<h2 id="thanks">Thanks</h2>
<p>After completing a rough draft of this blog post, I emailed all three main servant developers (<a href="https://github.com/jkarni">Julian K. Arni</a>, <a href="http://alpmestan.com/">Alp Mestanogullari</a>, and <a href="https://github.com/soenkehahn">Sönke Hahn</a>) asking them if they would review it. Since it’s such a long blog post, and I’m sure they are busy guys, I was expecting <em>maybe</em> one of them to respond, but to my surprise, <strong>all three</strong> responded <strong>within hours</strong> of sending the email. They all took the time not only to read through this post, but to give very helpful feedback.</p>
<p>If any of you ever come to Tokyo, dinner is on me!</p>
<h2 id="footnotes">Footnotes</h2>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This article is also super long, so I really shouldn’t complain about length.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>The article <a href="https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md">A Gentle Introduction to Monad Transformers</a> might be a good place to start if you’re not too familiar with Monad transformers. However, if you’re not too familiar with Monad transformers, the rest of this article will probably be quite challenging.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>It may be easier to reason about this code using convenient type synonyms. Originally we had this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAPI ::</span> <span class="dt">ServerT</span> (<span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]) (EitherT ...)</span>
    <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> (<span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]) (EitherT ...)</span>
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<p>But it may be be easier to think about it like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DogsAPI</span> <span class="fu">=</span> <span class="st">&quot;dogs&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [Int]</span>

<span class="kw">type</span> <span class="dt">CatsAPI</span> <span class="fu">=</span> <span class="st">&quot;cats&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [String]</span>

<span class="ot">myAPI ::</span> <span class="dt">ServerT</span> <span class="dt">DogsAPI</span> (<span class="dt">EitherT</span> <span class="fu">...</span>)
    <span class="fu">:&lt;|&gt;</span> <span class="dt">ServerT</span> <span class="dt">CatsAPI</span> (<span class="dt">EitherT</span> <span class="fu">...</span>)
myAPI <span class="fu">=</span> dogNums <span class="fu">:&lt;|&gt;</span> cats</code></pre></div>
<a href="#fnref3">↩</a></li>
<li id="fn4"><p>In fact, even if we didn’t use <code>path</code>, we would <em>still</em> have to use a <code>Proxy</code>. This is because the arguments to a type family declared inside a typeclass need to be used standalone in functions in that type class.</p>
<p>It’s awkward to explain, but it is pretty easy to understand when you see an example.</p>
<p>In the following typeclass, there is one one type family and two functions using that type family:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Baz</span> a <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Hoge</span> a
<span class="ot">    myGoodFunc ::</span> a <span class="ot">-&gt;</span> <span class="dt">Hoge</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="ot">    myBadFunc ::</span> <span class="dt">Hoge</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span></code></pre></div>
<p>Now imagine we had the following two instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Baz</span> <span class="dt">String</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Hoge</span> <span class="dt">String</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">    myGoodFunc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myGoodFunc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">    myBadFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myBadFunc <span class="fu">=</span> <span class="fu">...</span>

<span class="kw">instance</span> <span class="dt">Baz</span> <span class="dt">Text</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Hoge</span> <span class="dt">Text</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">    myGoodFunc ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myGoodFunc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">    myBadFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myBadFunc <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>We use <code>myGoodFunc</code> and <code>myBadFunc</code> like below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">exampleGood ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
exampleGood string int <span class="fu">=</span> myGoodFunc string int

<span class="ot">exampleBad ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
exampleBad int <span class="fu">=</span> myBadFunc int</code></pre></div>
<p>In <code>exampleGood</code>, GHC knows to pick the <code>myGoodFunc</code> from the <code>String</code> instance of the <code>Baz</code> typeclass because the first argument to <code>myGoodFunc</code> is a <code>String</code>.</p>
<p>However, in <code>exampleBad</code>, GHC doesn’t know which <code>myBadFunc</code> to pick. Should it pick <code>myBadFunc</code> from the <code>Baz Text</code> instance, or from the <code>Baz String</code> instance? It doesn’t have enough information to decide. GHC will throw a compilation error.</p>
<p>The <code>Baz</code> typeclass could be rewritten to make <code>myBadFunc</code> unambiguous.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Baz</span> a <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Hoge</span> a
<span class="ot">    myGoodFunc ::</span> a <span class="ot">-&gt;</span> <span class="dt">Hoge</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="ot">    myBadFunc ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Hoge</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span>

<span class="kw">instance</span> <span class="dt">Baz</span> <span class="dt">String</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Hoge</span> <span class="dt">String</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">    myGoodFunc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myGoodFunc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">    myBadFunc ::</span> <span class="dt">Proxy</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myBadFunc <span class="fu">=</span> <span class="fu">...</span>

<span class="kw">instance</span> <span class="dt">Baz</span> <span class="dt">Text</span> <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Hoge</span> <span class="dt">Text</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">    myGoodFunc ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myGoodFunc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">    myBadFunc ::</span> <span class="dt">Proxy</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
    myBadFunc <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p><code>exmapleBad</code> would also have to be rewritten:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">exampleBad ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
exampleBad int <span class="fu">=</span> myBadFunc int
<span class="co">-- becomes</span>
<span class="ot">exampleBad ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
exampleBad int <span class="fu">=</span> myBadFunc (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">String</span>) int</code></pre></div>
<p>Now GHC knows to call <code>myBadFunc</code> from the <code>Baz String</code> instance.</p>
<p>The <code>HasServer</code> typeclass is also using this <code>Proxy</code> trick. That is why passing a <code>Proxy</code> is necesary.<a href="#fnref4">↩</a></p></li>
</ol>
</div>
            </div>
        </div>
    </div>
</article>



    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="#">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="https://github.com/arow-oss">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <p class="copyright text-muted">Copyright ARoW Co., Ltd. 2015</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="../js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="../js/bootstrap.min.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="../js/clean-blog.js"></script>

</body>

</html>
